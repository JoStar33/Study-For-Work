# 반복 렌더링(map)시에 key값을 index로 사용하면 생길 수 있는 이슈

key 에 index 값을 부여하면 배열 `데이터가 변경(삽입, 삭제, 재정렬) 됐을 때 성능 하락 이슈 O`

- 항목을 삽입하거나 삭제, 재정렬시 `렌더링 순서가 시간이 지남에 따라 달라짐`
- index 값 이외의 즉석에서 값을 생성하는 경우도 안됨(ex. key={랜덤 값 반환 함수})
- `key` 는 실제로 컴포넌트에 전달되지 않고 `리액트에서만 사용함`

> - [ 앞서 알아야 할 것 ]
> - 리액트는 메모리상의 `가상 돔`을 사용하여 렌더링을 진행
> - `현재 버전 vs 가상 버전`의 가상돔 비교하여 어떤 것을 렌더링할지 결정하는 방식 = `재조정`
> - 변경된 곳을 제외한 부분은 다시 렌더링하지 않으며 `성능 최적화`

## key 는 어떤 역할을 수행하나 ?

1. 가상 돔의 key prop
   : 리액트는 가상 돔 객체를 메모리상에 생성
   : React 16 이상 버전을 기준으로 Fiber Node 라고 불리는 객체는 아래와 같은 구조 가짐

```javascript
function FiberNode(
  tag: WorkTag,
  pendingPros: mixed,
  key: null | string,
  mode: TypeOfMode
) {
  // Instance
  this.tag = tag;
  this.key = key;
  this.elementType = null;
  this.type = null;
  this.stateNode = null;
}
```

2. 재조정 과정에서 key 의 역할

가상 돔 객체는 트리 구조를 가지고 있음 + 위의 `FiberNode` 가 해당 트리의 `개별 node`

- 두 개의 트리를 비교할 때, 최첨단 알고리즘을 사용하더라도 n 개의 엘리먼트에 대해 O(n3) 의 복잡도 가짐
  - 1000개의 엘리먼트를 그리기 위해서는 10억 번의 비교 연산 진행해야 함
  - 굉장히 비싼 연산으로, 다른 해결법 필요함

> - [ 리액트가 도입한 가정 ]
>
> 1. 타입이 다른 두 엘리먼트는 서로 다른 트리를 만들어 낸다.
>    : Type = Element Type
>    : ex ) <div> --> <span> 으로 달라질 경우 해당 트리 전체 비교, 타입이 그대로면 변경된 속성(property) 만 갱신
>
> 2. 개발자가 key props 을 전달해 어떤 자식 엘리먼트가 변경되지 말아야할지 표시해 준다.
>    : key의 역할 설명
>    : 개발자가 key prop 을 전달하여 자식 엘리먼트를 리렌더링하지 않도록 만든다는 것
>    : 즉, key prop 이 바뀌면 실제로 데이터가 변경되지 않았더라도, 이를 변경으로 간주 + 리렌더링

```html
<ul>
  <li>지송이</li>
  <li>황호세</li>
</ul>

<!-- 
* 이 리스트의 가장 하단에 li 를 추가해야 한다면? -> 해당 li 만 추가됨
* 가장 상단에 li 를 추가해야 한다면? -> 해당 컴포넌트를 모두 다시 연산해야함. 

이와 같은 상황을 key 를 사용함으로써 불필요한 연산 방지
2번 가정에 따라 key 값이 변하지 않는다면 연산을 다시 진행하지 X + 이미 있는 값 재활용
-->
```

## key 에 배열 index 를 전달했을 때

자바스크르립트의 배열에서 index 값 = 말 그대로 요소의 순서 번호

- so, 배열의 끝이 아닌 중간이나 처음에 값을 더하거나 삭제하면, 모든 index 값이 달라짐 + 연산이 이루어짐

## 정리

- 리액트는 `key prop`으로 해당 리스트 아이템을 다시 연산할지 말지 결정
- key prop에 index 값을 넣을 경우, 배열 순서가 바뀔 때마다 다시 연산하며 불필요한 비용이 발생합니다.
- key prop에 즉석에서 생성한 랜덤 값을 넣을 경우, 매번 key prop이 달라지며 연산도 다시 이뤄짐
- 따라서 key prop에는 `해당 요소의 고유값`(예: 회원 uuid 등)을 전달해 `불필요한 연산을 방지해야 함`

key prop 을 전달하지 않으면 자동으로 index 값을 부여함
